% ---------------------- %
% -- IMPORTS REQUIRED -- %
% ---------------------- %

% C
\RequirePackage{circledsteps}
\RequirePackage{commado}
% F
\RequirePackage{forloop}
% I
\RequirePackage{ifmtarg}
% M
\RequirePackage{mathtools}
% R
\RequirePackage{relsize}
% T
\RequirePackage{tkz-tab}
\RequirePackage{tnscom}
% U
\RequirePackage{upgreek}
\PassOptionsToPackage{Symbolsmallscale}{upgreek}
% X
\RequirePackage{xstring}
% Y
\RequirePackage{yhmath}

% TikZ libraries
\usetikzlibrary{calc}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{babel}


% --------------- %
% -- CONSTANTS -- %
% --------------- %

% Constants - START

% User's constants

\newcommand\param[1]{%
    \IfStrEqCase{#1}{%
        {gamma}{\upgamma}%
        {pi}{\uppi}%
        {tau}{\uptau}%
    }[\text{\textbf{#1}}]
}

% Classical constants
    
\newcommand\ggamma{\param{gamma}}
\newcommand\ppi{\param{pi}}
\newcommand\ttau{\param{tau}}
\newcommand\ee{\param{e}}
\newcommand\ii{\param{i}}
\newcommand\jj{\param{j}}
\newcommand\kk{\param{k}}

% Constants - END


% ------------------ %
% -- ABS FUNCTION -- %
% ------------------ %

% Source :
%    * https://tex.stackexchange.com/a/43009/6880
%
\DeclarePairedDelimiter\abs{\lvert}{\rvert}%

\let\@old@abs\abs
\def\abs{\@ifstar{\@old@abs}{\@old@abs*}}


% --------------------- %
% -- NAMED FUNCTIONS -- %
% --------------------- %

% Classical functions - START

\DeclareMathOperator{\pgcd}{\operatorname{pgcd}}
\DeclareMathOperator{\ppcm}{\operatorname{ppcm}}
\DeclareMathOperator{\acos}{\operatorname{acos}}
\DeclareMathOperator{\asin}{\operatorname{asin}}
\DeclareMathOperator{\atan}{\operatorname{atan}}
\DeclareMathOperator{\arccosh}{\operatorname{arccosh}}
\DeclareMathOperator{\arcsinh}{\operatorname{arcsinh}}
\DeclareMathOperator{\arctanh}{\operatorname{arctanh}}
\DeclareMathOperator{\acosh}{\operatorname{acosh}}
\DeclareMathOperator{\asinh}{\operatorname{asinh}}
\DeclareMathOperator{\atanh}{\operatorname{atanh}}
\DeclareMathOperator{\fch}{\operatorname{ch}}
\DeclareMathOperator{\fsh}{\operatorname{sh}}
\DeclareMathOperator{\fth}{\operatorname{th}}
\DeclareMathOperator{\afch}{\operatorname{ach}}
\DeclareMathOperator{\afsh}{\operatorname{ash}}
\DeclareMathOperator{\afth}{\operatorname{ath}}

\newcommand\expb[1]{\exp_{#1}}
\newcommand\logb[1]{\log_{#1}}

% Classical functions - END


% --------------------------- %
% -- DIFFERENTIAL CALCULUS -- %
% --------------------------- %

% Sources :
%    * http://forum.mathematex.net/latex-f6/en-tete-de-ds-t12933.html#p124908
%    * http://forum.mathematex.net/latex-f6/derivee-avec-un-d-droit-et-espace-t12932.html#p124930
%    * http://forum.mathematex.net/latex-f6/remplacer-des-espaces-par-autre-chose-t12952.html#p125062
%    * http://forum.mathematex.net/latex-f6/probleme-de-remplacement-de-cdots-t13047.html#p125782


% dd, partial and pp useful operators
%
% Argument #1: the exponent
% Argument #2: the variable
% Argument #3: the operator
% Argument #4: space before exponent
% Argument #5: space after exponent

\newcommand{\@diffOpe}[5]{%
    #3%
    \ifx0#1\else%
    	^{\kern#4#1\kern#5}\!%
	\fi%
    \hspace{0.07em}#2%
}

\DeclareRobustCommand\@dder{
    \mathop{}\mathopen{}\mathrm{d}
}

\newcommand\dd[2][0]{\@diffOpe{#1}{#2}{\@dder}{.05ex}{0.15ex}}

\let\original@partial\partial
\renewcommand{\partial}{%
    \original@partial\mathopen{}%
}

\newcommand\pp[2][0]{\@diffOpe{#1}{#2}{\partial}{.15ex}{0.15ex}}



% Common tools

\newcounter{@der@prime@counter}

\newcommand\@der@func@no@par[1]{%
	#1%
}

\newcommand\@der@func@ext@par[1]{%
	\left( #1 \right)%
}

\newcommand\@der@func@no@ext@par[1]{%
	( #1 )%
}


\newbool{@der@option@u}
\newbool{@der@option@e}
\newbool{@der@option@i}
\newbool{@der@option@f}
\newbool{@der@option@of}
\newbool{@der@option@sf}
\newbool{@der@option@osf}
\newbool{@der@option@p}
\newbool{@der@option@sp}


% Total derivate

%     + Abstraction

\newcommand\@der@usual[3]{%
	#1{#2}^{%
		\,%
       	\forloop[1]{@der@prime@counter}{0}{\value{@der@prime@counter} < #3}{%
        	\prime%
        }
    }
}


\newcommand\@der@exp[3]{%
	#1{#2}^{\left( #3 \right)}%
}


\newcommand\@der@sub[3]{
    \@dder%
    \IfStrEq{#2}{1}{}{%
	    ^{\kern.15ex#2\kern.15ex}%
	}%
	_{\kern.15ex#3\kern.15ex} #1%
}


\newcommand\@der@abstract@frac[4]{%
	#1{%
		\IfStrEq{#3}{1}{%
			\dd{#2}%
		}{%
			\dd[#3]{#2}%
		}%
	}{%
		{%
			\dd{#4}%
			\IfStrEq{#3}{1}{}{%
				^{#3}%
			}%
		}%
	}%
}

\newcommand\@der@dfrac[3]{%
    \@der@abstract@frac{\dfrac}{#1}{#2}{#3}%
}

\newcommand\@der@frac[3]{
    \@der@abstract@frac{\frac}{#1}{#2}{#3}%
}

\newcommand\@der@ope@frac[3]{
    \@der@abstract@frac{\frac}{}{#2}{#3}#1%
}

\newcommand\@der@ope@dfrac[3]{
    \@der@abstract@frac{\dfrac}{}{#2}{#3}#1%
}


%     + Simple version (no var. of derivation)

\newcommand\@validate@simple@der@option[1]{
	\IfEqCase{#1}{%
		{u}{\booltrue{@der@option@u}}%
		{e}{\booltrue{@der@option@e}}%
		{p}{\booltrue{@der@option@p}}%
		{sp}{\booltrue{@der@option@sp}}%
	}[%
        \PackageError{tnsana}{unknown option}%
                             {you can use u (default), e , p and sp}%
	]%
}


\newcommand\sder[3][u]{%
	\boolfalse{@der@option@u}%
	\boolfalse{@der@option@e}%
	\boolfalse{@der@option@p}%
	\boolfalse{@der@option@sp}%
	%
	\DoWithCSL\@validate@simple@der@option{#1}
	%
	\ifbool{@der@option@e}{}{%
		\booltrue{@der@option@u}%
	}%
	%
	\ifbool{@der@option@p}{%
		\let\parithere\@der@func@ext@par%
	}{%
		\ifbool{@der@option@sp}{%
			\let\parithere\@der@func@no@ext@par%
		}{%
			\let\parithere\@der@func@no@par%
		}%
	}%
	%
	\ifbool{@der@option@u}{%
		\let\callithere\@der@usual%
    }{%
		\let\callithere\@der@exp%
	}%
	\callithere{\parithere}{#2}{#3}%
}


%     + Strict version (this one needs the var. of derivation)

\newcommand\@validatee@der@option[1]{
	\IfEqCase{#1}{%
		{u}{\booltrue{@der@option@u}}%
		{e}{\booltrue{@der@option@e}}%
		{i}{\booltrue{@der@option@i}}%
		{f}{\booltrue{@der@option@f}}%
		{of}{\booltrue{@der@option@of}}%
		{sf}{\booltrue{@der@option@sf}}%
		{osf}{\booltrue{@der@option@osf}}%
		{p}{\booltrue{@der@option@p}}%
		{sp}{\booltrue{@der@option@sp}}%
	}[%
        \PackageError{tnsana}{unknown option}%
                             {you can use u (default), e , i , f , sf , oi , of , osf , p and sp}%
	]%
}


\newcommand\der[4][u]{%
	\boolfalse{@der@option@u}%
	\boolfalse{@der@option@e}%
	\boolfalse{@der@option@i}%
	\boolfalse{@der@option@f}%
	\boolfalse{@der@option@of}%
	\boolfalse{@der@option@sf}%
	\boolfalse{@der@option@osf}%
	\boolfalse{@der@option@p}%
	\boolfalse{@der@option@sp}%
	%
	\DoWithCSL\@validatee@der@option{#1}
	%
	\ifboolexpr{
		not(
			bool {@der@option@e}
			or
			bool {@der@option@i}
			or
			bool {@der@option@f}
			or
			bool {@der@option@of}
			or
			bool {@der@option@sf}
			or
			bool {@der@option@osf}
		)
    }{%
    	\booltrue{@der@option@u}%
    }{}
	% Usual
	\ifbool{@der@option@u}{%
		\sder[#1]{#2}{#3}
	% Exponent
	}{
    	\ifbool{@der@option@e}{%
    		\sder[#1]{#2}{#3}
    	}{
    % Indice or fraction like
        	\ifbool{@der@option@p}{%
        		\let\parithere\@der@func@ext@par%
        	}{%
        		\ifbool{@der@option@sp}{%
        			\let\parithere\@der@func@no@ext@par%
        		}{%
        			\let\parithere\@der@func@no@par%
        		}%
        	}%
	 % Big frac
	 		\ifbool{@der@option@f}{%
				\let\callithere\@der@dfrac%
	 % Small frac
	 		}{%
				\ifbool{@der@option@sf}{%
					\let\callithere\@der@frac%
	 % Indice
	 			}{%
					\ifbool{@der@option@i}{%
						\let\callithere\@der@sub%
	% Big frac ope
					}{
						\ifbool{@der@option@of}{%
							\let\callithere\@der@ope@dfrac%
						}{
	% Small frac ope
							\ifbool{@der@option@osf}{%
								\let\callithere\@der@ope@frac%
							}{}%
						}%
					}%
				}%
	 		}%
	% Let's do the job
			\callithere{\parithere{#2}}{#3}{#4}%
		}%
	}%
}


%     + Operator for total derivations

\newcommand\@validate@der@operator@option[1]{
	\IfEqCase{#1}{%
		{f}{\booltrue{@der@option@f}}%
		{sf}{\booltrue{@der@option@sf}}%
		{i}{\booltrue{@der@option@i}}%
	}[%
        \PackageError{tnsana}{unknown option}%
                             {you can use f (default), sf and i}%
	]%
}


\newcommand\derope[3][f]{%
	\boolfalse{@der@option@f}%
	\boolfalse{@der@option@sf}%
	\boolfalse{@der@option@i}%
	%
	\DoWithCSL\@validate@der@operator@option{#1}
	%
	\ifbool{@der@option@sf}{}{%
		\ifbool{@der@option@i}{}{%
			\booltrue{@der@option@f}%
		}%
	}%
	\der[#1]{}{#2}{#3}%
}



% Total derivate

%     + Abstraction

\newcommand\@pder@abstract@frac[4]{%
    #1{%
        \pp[#4]{#2}%
    }{%
% ARG 1 = Separator: |
% ARG 2 = All parts: what the user types !
% ARG 3 = Before   : nothing here
% ARG 4 = Between  : ;
% ARG 5 = After    : nothing here
        \tns@multi@args{|}{#3}{\partial}{\,\partial}{}%
    }
}

\newcommand\@pder@dfrac[3]{%
	\@pder@abstract@frac{\dfrac}{#1}{#2}{#3}%
}

\newcommand\@pder@frac[3]{%
	\@pder@abstract@frac{\frac}{#1}{#2}{#3}%
}

\newcommand\@pder@ope@dfrac[3]{%
	\@pder@abstract@frac{\dfrac}{}{#2}{#3}#1%
}

\newcommand\@pder@ope@frac[3]{%
	\@pder@abstract@frac{\frac}{}{#2}{#3}#1%
}



\newcommand\@pder@sub[3]{
% The following command works because xstring traits {...} like a single character.
    \noexpandarg
    \StrSubstitute{#2}{^}{\@der@func@no@ext@par}[\@index]
    \partial%
    ^{\kern.15ex#3\kern.15ex}%
    _{\expandafter\StrSubstitute\expandafter{\@index}{|}{\kern.05em,\kern.05em}}%
    #1%
    \expandarg
}


%     + With the function given

\newcommand\@validate@pder@option[1]{
	\IfEqCase{#1}{%
		{f}{\booltrue{@der@option@f}}%
		{of}{\booltrue{@der@option@of}}%
		{sf}{\booltrue{@der@option@sf}}%
		{osf}{\booltrue{@der@option@osf}}%
		{i}{\booltrue{@der@option@i}}%
		{p}{\booltrue{@der@option@p}}%
		{sp}{\booltrue{@der@option@sp}}%
	}[%
        \PackageError{tnsana}{unknown option}%
                             {you can use f (default), sf, of, osf, i, p and sp}%
	]%
}


\newcommand\pder[4][f]{%
	\boolfalse{@der@option@f}%
	\boolfalse{@der@option@of}%
	\boolfalse{@der@option@sf}%
	\boolfalse{@der@option@osf}%
	\boolfalse{@der@option@i}%
	\boolfalse{@der@option@p}%
	\boolfalse{@der@option@sp}%
	%
	\DoWithCSL\@validate@pder@option{#1}
	%
	%
	\ifboolexpr{
		not(
			bool {@der@option@of}
			or
			bool {@der@option@sf}
			or
			bool {@der@option@osf}
			or
			bool {@der@option@i}
		)
    }{%
    	\booltrue{@der@option@f}%
    }{}%
    % Parentheses or not
    \ifbool{@der@option@p}{%
    	\let\parithere\@der@func@ext@par%
    }{%
    	\ifbool{@der@option@sp}{%
        	\let\parithere\@der@func@no@ext@par%
        }{%
        	\let\parithere\@der@func@no@par%
        }%
    }%
    % Expo total
    \IfStrEq{#4}{1}{%
    	\def\expotot{}
    }{%
    	\def\expotot{#4}
    }%
	% Big frac
	\ifbool{@der@option@f}{%
		\let\callithere\@pder@dfrac%
	}{%
    % Big frac ope
		\ifbool{@der@option@of}{%
			\let\callithere\@pder@ope@dfrac%
		}{%
	% Small frac
			\ifbool{@der@option@sf}{%
				\let\callithere\@pder@frac%
			}{%
	% Small frac ope
				\ifbool{@der@option@osf}{%
					\let\callithere\@pder@ope@frac%
				}{%
	% Indice
					\ifbool{@der@option@i}{%
						\let\callithere\@pder@sub%
					}{}%
				}%
			}%
		}%
	}%
	% Let's do the job
	\callithere{\parithere{#2}}{#3}{\expotot}%
}



%     + Operator for partiaal derivations

\newcommand\pderope[3][f]{%
	\boolfalse{@der@option@f}%
	\boolfalse{@der@option@sf}%
	\boolfalse{@der@option@i}%
	%
	\DoWithCSL\@validate@der@operator@option{#1}
	%
	\ifbool{@der@option@sf}{}{%
		\ifbool{@der@option@i}{}{%
			\booltrue{@der@option@f}%
		}%
	}%
	\pder[#1]{}{#2}{#3}%
}


% ------------ %
% -- TABLES -- %
% ------------ %

% Better style for arrowhead !

\tkzTabSetup[arrowstyle = triangle 60]


% Graph Sign to decorate tkzTables.
%
% Source
%    + https://tex.stackexchange.com/a/549546/6880
%    + https://groups.google.com/forum/#!topic/fr.comp.text.tex/X6aIq-SZDFA

\newcounter{@tkz@tab@nbline}

\newcommand\@tkzdeco@node@middle[1]{
    \coordinate (M) at ($(T2#1)!.5!(T2\the\numexpr#1+1\relax)$)
}

% Comment a line
%
%    #1 : color
%    #2 : nb of the line
%    #3 : text
\newcommand\comLine[3][blue]{
    \@tkzdeco@node@middle{#2};
    \path
        (M.east) +(.6,0) node[right, #1]{\footnotesize#3}
    ;
}


% Options : @gso@ = @graph@sign@option
\newcounter{@gso@nb@functions}
\newcommand\@gso@function{}

\newcounter{@gso@nb@a@constraints}
\newcommand\@gso@a@constraints{}

\newcounter{@gso@nb@d@constraints}
\newcommand\@gso@d@constraints{}


\newcommand\@validate@graph@sign@option[1]{%
    % Parameter a
    \IfSubStr{an,ap}{#1}{%
        \stepcounter{@gso@nb@a@constraints}%
        \renewcommand\@gso@a@constraints{@#1}%
    }{%
    % Parameter d
        \IfSubStr{dn,dp,dz}{#1}{%
            \stepcounter{@gso@nb@d@constraints}%
            \renewcommand\@gso@d@constraints{@#1}%
        }{%
    % Functions with parameters
            \IfEqCase{#1}{%
                {ax+b}{%
                    \renewcommand\@gso@function{line}%
                }%
                {ax2+bx+c}{%
                    \renewcommand\@gso@function{parabola}%
                }%
            }[%
                \PackageError{tnsana}{unknown option for graphSign}%
                                     {Illegal option given for graphSign : #1 .}%
            ]%
            \stepcounter{@gso@nb@functions}%
        }% END OF ELSE for parameter d 
    }% END OF ELSE for parameter a 
}


%    #1 : color
%    #2 : nb of the line
%    #3 : kind of graph
\newcommand\graphSign[3][blue]{%
    \renewcommand\@gso@function{}
    \renewcommand\@gso@a@constraints{}
    \renewcommand\@gso@d@constraints{}
    % Processing the options
    \setcounter{@gso@nb@functions}{0}
    \setcounter{@gso@nb@a@constraints}{0}
    \setcounter{@gso@nb@d@constraints}{0}
    %
    \DoWithCSL\@validate@graph@sign@option{#3}
    % Only one kind of function ?
    \ifnum\value{@gso@nb@functions}=1\else%
        \PackageError{tnsana}{only one kind of function can be given graphSign}%
                             {Number of kinds of function given to graphSign = \the@gso@nb@functions. This is illegal !}%
    \fi%
    % Line need only one constraint for a.
    \IfStrEq{\@gso@function}{line}{%
        \ifnum\value{@gso@nb@d@constraints}=0\else%
            \PackageError{tnsana}{constraints for d with lines are nonsense for graphSign}%
                                 {Lines for graphSign need only one constraint for a.}%
        \fi%
        %
        \ifnum\value{@gso@nb@a@constraints}=1\else%
            \PackageError{tnsana}{one constraint for a with lines is needed for graphSign}%
                                 {Number of constraints for a given to graphSign = \the@gso@nb@a@constraints. This is illegal !}%
        \fi%
    }{%
    % Parabola need only one constraint for a and also one for d.
        \IfStrEq{\@gso@function}{parabola}{%
            \ifnum\value{@gso@nb@d@constraints}=1\else%
                \PackageError{tnsana}{one constraint for d with parabolas is needed for graphSign}%
                                     {Number of constraints for d given to graphSign = \the@gso@nb@a@constraints. This is illegal !}%
            \fi%
            %
            \ifnum\value{@gso@nb@a@constraints}=1\else%
                \PackageError{tnsana}{one constraint for a with lines is needed for graphSign}%
                                     {Number of constraints for a given to graphSign = \the@gso@nb@a@constraints. This is illegal !}%
            \fi%
        %
        }{}%
    }%
    % Call of the good function
    \csname    @sign@\@gso@function\@gso@a@constraints\@gso@d@constraints\endcsname{#1}{#2}
    % Looking for invalid options 
    % Everything is ok.
}


% LINES
%
% ax+b , ap  -->  \@sign@line@ap
% ax+b , an  -->  \@sign@line@an


% Abstraction for the lines
%
%    #1 : color
%    #2 : nb of the line
%    #3 : the root
%    #4 : 1st ordinate
%    #5 : 2nd ordinate
%    #6 : 1st sign
%    #7 : 2nd sign
%    #8 : 1st shifts
%    #9 : 2nd shifts
\newcommand\@abtrasct@sign@line[9]{
    \@tkzdeco@node@middle{#2};
    \path
        (M.east) +(.75,0) pic[right]{%
            code = {
            	% Axe of abscisses
                \draw[->, -Latex, #1] (-0.1,0)--+(0:2.7);
                % Plot of the function with the signs.
                \draw[#1]
                    (0, #4)   node[xshift = -1.5mm, yshift =#8]
                             {\CircledText{\scriptsize#6}}
                    --
                    (2.5, #5) node[xshift = -4.5mm, yshift = #9]
                             {\CircledText{\scriptsize#7}};
                % 1 root
                \path (1.25,0) node[above, #1]{\footnotesize#3};
        }
    };
}


%    #1 : color
%    #2 : nb of the line
%    #3 : the root
\newcommand\@sign@line@an[3]{
    \@abtrasct@sign@line{#1}{#2}{#3}  %
                        {.65} {-.65}  % 1st and 2nd ordinates
                        {$+$} {$-$}   % 1st and 2nd signs
                        {-4mm}{3.5mm} % 1st and 2nd y shifts
}

%    #1 : color
%    #2 : nb of the line
%    #3 : the root
\newcommand\@sign@line@ap[3]{
    \@abtrasct@sign@line{#1}{#2}{#3}   %
                        {-.65}{.65}    % 1st and 2nd ordinates
                        {$-$} {$+$}    % 1st and 2nd signs
                        {4mm} {-3.5mm} % 1st and 2nd y shifts
}


% PARABOLAS

% ax2+bx+c , ap , dp  -->  \@sign@parabola@ap@dp
% ax2+bx+c , ap , dn  -->  \@sign@parabola@ap@dn
% ax2+bx+c , ap , dz  -->  \@sign@parabola@ap@dz
% ...etc


% a > 0 and delta > 0
%
%    #1 : color
%    #2 : nb of the line
%    #3 : smaller root
%    #4 : bigger root
\newcommand\@sign@parabola@ap@dp[4]{
    \@tkzdeco@node@middle{#2};
    \path
        (M.east) +(.75,0) pic[right]{%
            code = {
                % Axe of abscisses
                \draw[->, -Latex, #1] (-0.1,0)--+(0:2.7);
                % Plot of the function.
                \draw[#1] (0.25,.6) parabola bend (1.25,-.6) (2.25,.6);
                % The signs.
                \path (.4,.3)     node[left, #1]
                                   {\CircledText{\scriptsize$+$}};
                \path (1.25,0.03) node[below, #1]
                                   {\CircledText{\scriptsize$-$}};
                \path (2.1,.3)    node[right, #1]
                                   {\CircledText{\scriptsize$+$}};
                % 2 roots
                \path (.32,0)  node[below, #1]
                               {\footnotesize#3};
                \path (2.18,0) node[below, #1]
                               {\footnotesize#4};
        	}
    	};
}


% a < 0 and delta > 0
%
%    #1 : color
%    #2 : nb of the line
%    #3 : smaller root
%    #4 : bigger root
\newcommand\@sign@parabola@an@dp[4]{
    \@tkzdeco@node@middle{#2};
    \path
        (M.east) +(.75,0) pic[right]{%
            code = {
                % Axe of abscisses
                \draw[->, -Latex, #1] (-0.1,0)--+(0:2.7);
                % Plot of the function.
                \draw[#1] (0.25,-.6) parabola bend (1.25,.6) (2.25,-.6);
                % The signs.
                \path (.4,-.3)     node[left, #1]
                                   {\CircledText{\scriptsize$-$}};
                \path (1.25,-0.03) node[above, #1]
                                   {\CircledText{\scriptsize$+$}};
                \path (2.1,-.3)    node[right, #1]
                                   {\CircledText{\scriptsize$-$}};
                % 2 roots
                \path (.32,0)  node[above, #1]
                               {\footnotesize#3};
                \path (2.18,0) node[above, #1]
                               {\footnotesize#4};
        	}
    	};
}


% Abstraction for the parabolas with delta = 0
%
%    #1 : color
%    #2 : nb of the line
%    #3 : the root
%    #4 : y shift
%    #5 : 1st ordinate
%    #6 : 2nd ordinate
%    #7 : sign
%    #8 : position
\newcommand\@abtrasct@sign@parabola@dz[8]{
    \@tkzdeco@node@middle{#2};
    \path
        (M.east) +(.75,0) pic[right]{%
            code = {
                % Axe of abscisses
                \draw[->, -Latex, #1] (-0.1,#6)--+(0:2.7);
                % Plot of the function.
                \draw[#1] (0.25,#5) parabola bend (1.25,#6) (2.25,#5);
                % The signs.
                \path (.5,#8) node[left, #1]
                              {\CircledText{\scriptsize#7}};
                \path (2,#8)  node[right, #1]
                              {\CircledText{\scriptsize#7}};
                % 1 root
                \path (1.25,#6) node[yshift = #4, #1]
                                {\footnotesize#3};
        	}
    	};
}


% a > 0 and delta = 0
%
%    #1 : color
%    #2 : nb of the line
%    #3 : root
\newcommand\@sign@parabola@ap@dz[3]{
	\@abtrasct@sign@parabola@dz{#1}{#2}         %
                               {#3}{0mm, above} % The root and its y shift
                               {.6}{-.6}        % 1st and 2nd ordinates
                               {$+$}{-.3}       % The sign and its position
}


% a < 0 and delta = 0
%
%    #1 : color
%    #2 : nb of the line
%    #3 : root
\newcommand\@sign@parabola@an@dz[3]{
	\@abtrasct@sign@parabola@dz{#1}{#2}           %
                               {#3}{-.1mm, below} % The root and its y shift
                               {-.6}{.6}          % 1st and 2nd ordinates
                               {$-$}{.3}          % The sign and its position
}


% Abstraction for the parabolas with delta < 0
%
%    #1 : color
%    #2 : nb of the line
%    #3 : y of the axe
%    #4 : 1st ordinate
%    #5 : 2nd ordinate
%    #6 : sign
%    #7 : ordinate
%    #8 : position
\newcommand\@abtrasct@sign@parabola@dn[8]{
    \@tkzdeco@node@middle{#2};
    \path
        (M.east) +(.75,0) pic[right]{%
            code = {
                % Axe of abscisses
                \draw[->, -Latex, #1] (-0.1,#3)--+(0:2.7);
                % Plot of the function.
                \draw[#1] (0.35,#4) parabola bend (1.25,#5) (2.15,#4);
                % The sign.
                \path (1.25,#7) node[#8, #1]
                              {\CircledText{\scriptsize#6}};
        	}
    	};
}


% a > 0 and delta < 0
%
%    #1 : color
%    #2 : nb of the line
\newcommand\@sign@parabola@ap@dn[2]{
	\@abtrasct@sign@parabola@dn{#1}{#2}          %
                               {-.55}            % y of the axe
                               {.57}{-.4}        % 1st and 2nd ordinates
                               {$+$}{.3}{below} % The sign, its ordinate and its position
}



\newcommand\@sign@parabola@an@dn[2]{
	\@abtrasct@sign@parabola@dn{#1}{#2}           %
                               {.55}              % y of the axe
                               {-.57}{.4}         % 1st and 2nd ordinates
                               {$-$}{-.3}{above} % The sign, its ordinate and its position
}


% ----------------------- %
% -- INTEGRAL CALCULUS -- %
% ----------------------- %

% Source for minimizing spaces between consecutive integrals :
%    * http://forum.mathematex.net/latex-f6/integrale-triple-t13312.html#p128016

% Consecutive integrals

\let\stdint\int
\DeclareRobustCommand{\int}{%
    \stdint\operator@followup{\@ifnextchar{\int}{\!\!}{}}%
}

\def\operator@followup#1{%
    \@ifnextchar{^}{\operator@followup@sup{#1}}%
        {\operator@followup@nosup{#1}}%
}

\def\operator@followup@sup#1^#2{%
    \@ifnextchar{_}{\operator@followup@sup@sub{#1}^{#2}}%
        {\operator@followup@sup@nosub{#1}^{#2}}%
}

\def\operator@followup@sup@sub#1^#2_#3{%
    \operator@followup@{#1}{#2}{#3}%
}

\def\operator@followup@sup@nosub#1^#2{%
    \operator@followup@{#1}{#2}{}%
}

\def\operator@followup@nosup#1{%
    \@ifnextchar{_}{\operator@followup@nosup@sub{#1}}
        {\operator@followup@nosup@nosub{#1}}%
}

\def\operator@followup@nosup@sub#1_#2{%
    \@ifnextchar{^}{\operator@followup@nosup@sub@sup{#1}_{#2}}
        {\operator@followup@nosup@sub@nosup{#1}_{#2}}%
}

\def\operator@followup@nosup@sub@sup#1_#2^#3{%
    \operator@followup@{#1}{#3}{#2}%
}

\def\operator@followup@nosup@sub@nosup#1_#2{%
    \operator@followup@{#1}{}{#2}%
}

\def\operator@followup@nosup@nosub#1{%
    \operator@followup@{#1}{}{}%
}

\def\operator@followup@#1#2#3{%
    ^{#2}_{#3}#1%
}


% Integration

\newcommand\integrate{\@ifstar{\@integrate@star}{\@integrate@no@star}}

\newcommand\@integrate@star[4]{%
	\int_{#1}^{#2} #3 \dd{#4}%
}

\newcommand\@integrate@no@star[4]{%
	\@integrate@star{#4\,=\,#1}{#4\,=\,#2}{#3}{#4}%
}


\newcommand\dintegrate{\@ifstar{\@dintegrate@star}{\@dintegrate@no@star}}

\newcommand\@dintegrate@star[4]{%
	{\displaystyle\integrate*{#1}{#2}{#3}{#4}}%
}

\newcommand\@dintegrate@no@star[4]{%
	{\displaystyle\integrate{#1}{#2}{#3}{#4}}%
}


% The hook operator

\newcommand\@hook@small@vertical@phantom[1]{%
	\vphantom{\text{\relsize{1.1}$#1$}}%
}

\newcommand\@hook@big@vertical@phantom{%
	\vphantom{\relsize{1.25}{\text{$\displaystyle F_1^2$}}}%
}

\newcommand\@abstract@hook[4][b]{%
    \IfEqCase{#1}{%
        {b}{%
			\left[%
				\@hook@small@vertical@phantom{#4}%
				\,#4\,%
			\right]%
        }{sb}{%
			\left[%
				\@hook@big@vertical@phantom \right. \!\!%
				\,#4\,%
				\left. \@hook@big@vertical@phantom \!\!%
			\right]%
        }{r}{%
            \left. #4\, \right\rvert%
        }{sr}{%
            #4\, {\text{\relsize{1.5}$\rvert$}}%
        }%
    }[
    	\PackageError{tnsana}{unknown option}%
                             {You can use b (default), sb, r or sr.}
    ]%
	_{\,#2}^{\,#3}%
}


\newcommand\hook{\@ifstar{\@hook@star}{\@hook@no@star}}

\newcommand\@hook@star[5][b]{%
	\@abstract@hook[#1]{#2}{#3}{#4}%
}

\newcommand\@hook@no@star[5][b]{%
	\@abstract@hook[#1]{#5\,=\,#2}{#5\,=\,#3}{#4}%
}
